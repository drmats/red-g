<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>action.ts - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-redux.html">redux</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~actionCreators">actionCreators</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~bindActionCreator">bindActionCreator</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~bindActionCreators">bindActionCreators</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~bindActionCreatorsTree">bindActionCreatorsTree</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~createReducer">createReducer</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~defineActionCreator">defineActionCreator</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~emptyActionCreators">emptyActionCreators</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~isACWithPayload">isACWithPayload</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~isWithPayload">isWithPayload</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~isWithTypeField">isWithTypeField</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~payloadActionCreators">payloadActionCreators</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-redux.html#~sliceReducer">sliceReducer</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">action.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Redux action tools.
 *
 * @module redux
 * @license Apache-2.0
 * @copyright Mat. 2020-present
 */

/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-return */

import {
    isString,
    toBool,
    type AllowSubset,
    type Arr,
    type Fun,
    type NonConstEnum,
    type Override,
} from "@xcmats/js-toolbox/type";
import { objectMap } from "@xcmats/js-toolbox/struct";




/**
 * redux-compatible Action interface.
 */
export interface ReduxCompatAction&lt;ActionType extends string = string> {
    type: ActionType;
}




/**
 * redux-compatible AnyAction interface.
 */
export interface ReduxCompatUnknownAction extends ReduxCompatAction {
    [extraProps: string]: unknown;
}




/**
 * Unique, private identifier distinguishing
 * between EmptyAction and PayloadAction (statically and in runtime).
 */
const payload = Symbol("payload");




/**
 * Empty action consists just of { type: ActionType } field.
 */
export interface EmptyAction&lt;
    ActionType extends string = string,
> extends ReduxCompatAction&lt;ActionType> {
    [payload]: false;
}




/**
 * Action with payload: { type: ActionType, payload: PayloadType }
 */
export interface PayloadAction&lt;
    PayloadType = any,
    ActionType extends string = string,
> extends ReduxCompatAction&lt;ActionType> {
    [payload]: true;
    payload: PayloadType;
}




/**
 * Empty action or action carrying payload.
 */
export type Action&lt;
    PayloadType = any,
    ActionType extends string = string,
> =
    | EmptyAction&lt;ActionType>
    | PayloadAction&lt;PayloadType, ActionType>;




/**
 * Type predicate - does a given action carry payload?
 */
export function isWithPayload&lt;PayloadType, ActionType extends string> (
    a: Action&lt;PayloadType, ActionType>,
): a is PayloadAction&lt;PayloadType, ActionType> {
    return a[payload];
}




/**
 * Action creator not carrying anything else than just `type` field.
 */
export interface EmptyActionCreator&lt;
    ActionType extends string,
> extends EmptyAction&lt;ActionType> {
    (): EmptyAction&lt;ActionType>;
}




/**
 * Action creator carrying payload (more than just `type`).
 */
export interface PayloadActionCreator&lt;
    PayloadType = any,
    ActionType extends string = string,
    Args extends Arr = Arr,
> extends EmptyAction&lt;ActionType> {
    (...args: Args): PayloadAction&lt;PayloadType, ActionType>;
}




/**
 * Any action creator (carrying just `type` or `type` and `payload`).
 */
export interface ActionCreator&lt;
    PayloadType = any,
    ActionType extends string = string,
    Args extends Arr = Arr,
> extends EmptyAction&lt;ActionType> {
    (...args: Args): Action&lt;PayloadType, ActionType>;
}




/**
 * Type predicate - not exposed red-g's internal.
 */
export function isACWithPayload&lt;
    PayloadType,
    ActionType extends string,
    Args extends Arr = Arr,
> (
    a: ActionCreator&lt;PayloadType, ActionType, Args>,
): a is PayloadActionCreator&lt;PayloadType, ActionType, Args> {
    return a[payload];
}




/**
 * Redux action creator definer.
 *
 * @function defineActionCreator
 * @param actionType Action type
 * @param creator Optional custom function returning payload.
 * @returns Action creator function.
 */
export function defineActionCreator&lt;
    ActionType extends string,
> (actionType: ActionType):
    EmptyActionCreator&lt;ActionType>;
export function defineActionCreator&lt;
    ActionType extends string,
    PayloadType,
    Args extends Arr,
> (actionType: ActionType, creator?: Fun&lt;Args, PayloadType>):
    PayloadActionCreator&lt;PayloadType, ActionType, Args>;
export function defineActionCreator&lt;
    ActionType extends string,
    PayloadType,
    Args extends Arr,
> (actionType: ActionType, creator?: Fun&lt;Args, PayloadType>):
    ActionCreator&lt;PayloadType, ActionType, Args> {
    const actionCreator: any = !creator ?
        () => ({
            type: actionType,
            [payload]: false,
        }) :
        (...args: Args) => ({
            type: actionType,
            [payload]: true,
            payload: creator(...args),
        });
    actionCreator.type = actionType;
    actionCreator[payload] = toBool(creator);
    return actionCreator;
}




/**
 * Construct interface based on `ActionEnum`. Consist of empty action
 * creators (action creators without payload - just `type` field).
 */
export type EmptyActionCreators&lt;
    ActionEnum extends NonConstEnum&lt;string, string>,
> = {
    [K in keyof ActionEnum]: EmptyActionCreator&lt;ActionEnum[K]>;
};




/**
 * Construct object whose keys correspond to `actionEnum` keys and
 * values consists of empty action creators for each type. Conforms to
 * `EmptyActionCreators&lt;ActionEnum>` interface.
 *
 * @function emptyActionCreators
 * @param actionEnum Enum upon which an EmptyActionCreators object is built.
 * @returns EmptyActionCreators object.
 */
export function emptyActionCreators&lt;
    ActionEnum extends NonConstEnum&lt;string, string>,
> (
    actionEnum: ActionEnum,
): EmptyActionCreators&lt;ActionEnum> {
    const actions = {} as EmptyActionCreators&lt;ActionEnum>;
    for (const actionType in actionEnum) {
        actions[actionType] = defineActionCreator(actionEnum[actionType]);
    }
    return actions;
}




/**
 * Take `ActionEnum` type with `PayloadCreators` object type and construct
 * `PayloadActionCreators` on its basis.
 *
 * Constructed `PayloadActionCreators` object type consists only of keys
 * that are also present in `ActionEnum` type (all other keys are dropped).
 */
export type PayloadActionCreators&lt;
    ActionEnum extends NonConstEnum&lt;string, string>,
    PayloadCreators,
> = {
    [K in Extract&lt;keyof PayloadCreators, keyof ActionEnum>]:
        PayloadCreators[K] extends Fun&lt;infer Args, infer PayloadType> ?
            PayloadActionCreator&lt;PayloadType, ActionEnum[K], Args> : never;
};




/**
 * Take empty action creators object based on `ActionEnum` type
 * (an object with all action creators not carrying anything besides
 * `type` property) and `PayloadCreators` object consisting of plain
 * javascript functions taking arguments and returning values.
 *
 * `PayloadCreators` object type is constrained to be a subset of `ActionEnum`
 * type (in the sense of `AllowSubset` type defined in `type/utils.ts`).
 *
 * Create fully typed action creators object with all action creators
 * defined as `EmptyActionCreator` or `PayloadActionCreator`.
 *
 * @function payloadActionCreators
 * @param emptyActionCreators EmptyActionCreators object
 * @param payloadCreators Object with payload creators.
 * @returns ActionCreators object.
 */
export function payloadActionCreators&lt;
    ActionEnum extends NonConstEnum&lt;string, string>,
    PayloadCreators extends
        &amp; AllowSubset&lt;ActionEnum, PayloadCreators>
        &amp; Partial&lt;Record&lt;keyof ActionEnum, Fun>>,
> (
    emptyActionCreators: EmptyActionCreators&lt;ActionEnum>,
    payloadCreators: PayloadCreators,
):
    Override&lt;
        typeof emptyActionCreators,
        PayloadActionCreators&lt;ActionEnum, PayloadCreators>
    >
{
    return Object.assign(
        emptyActionCreators,
        objectMap(payloadCreators) &lt;keyof ActionEnum>(([key, creator]) => [
            key, defineActionCreator(emptyActionCreators[key].type, creator),
        ]),
    );
}




/**
 * Construct action slice for provided action enum. Optionally
 * define action creators with payload. Statically typed.
 *
 * @function actionCreators
 * @param actionEnum Enum upon which an ActionCreators object is built.
 * @param payloadCreators Optional object with payload creators.
 * @returns ActionCreators object.
 */
export function actionCreators&lt;
    ActionEnum extends NonConstEnum&lt;string, string>,
> (actionEnum: ActionEnum): EmptyActionCreators&lt;ActionEnum>;
export function actionCreators&lt;
    ActionEnum extends NonConstEnum&lt;string, string>,
    PayloadCreators extends
        &amp; AllowSubset&lt;ActionEnum, PayloadCreators>
        &amp; Partial&lt;Record&lt;keyof ActionEnum, Fun>>,
> (
    actionEnum: ActionEnum,
    payloadCreators?: PayloadCreators,
):
    Override&lt;
        EmptyActionCreators&lt;ActionEnum>,
        PayloadActionCreators&lt;ActionEnum, PayloadCreators>
    >;
export function actionCreators&lt;
    ActionEnum extends NonConstEnum&lt;string, string>,
    PayloadCreators extends
        &amp; AllowSubset&lt;ActionEnum, PayloadCreators>
        &amp; Partial&lt;Record&lt;keyof ActionEnum, Fun>>,
> (
    actionEnum: ActionEnum,
    payloadCreators?: PayloadCreators,
):
    | EmptyActionCreators&lt;ActionEnum>
    | Override&lt;
        EmptyActionCreators&lt;ActionEnum>,
        PayloadActionCreators&lt;ActionEnum, PayloadCreators>
    >
{
    const eac = emptyActionCreators(actionEnum);
    if (payloadCreators) {
        return payloadActionCreators(eac, payloadCreators);
    } else {
        return eac;
    }
}




/**
 * Dispatch-bound action creators and thunks contain type field.
 */
export type WithTypeField&lt;T, ActionType extends string = string> =
    &amp; T
    &amp; { type: ActionType };




/**
 * Checks for `type` field presence in a given candidate.
 */
export const isWithTypeField = &lt;
    T,
    ActionType extends string = string,
>(c: T): c is WithTypeField&lt;T, ActionType> => {
    try {
        return (
            typeof c !== "undefined" &amp;&amp;
            c != null &amp;&amp;
            isString((c as { type?: ActionType }).type)
        );
    } catch {
        return false;
    }
};




/**
 * Infer return type if `T` is function, return `T` itself otherwise.
 */
type ReturnTypeOrType&lt;T> = T extends (...args: any) => infer R ? R : T;




/**
 * Binds given action creator or thunk with chosen store's dispatch.
 *
 * @function bindActionCreator
 * @param actionCreatorOrThunk any action creator or thunk
 * @param dispatch redux store's `dispatch` function
 * @returns bound action creator or thunk dispatch
 */
export function bindActionCreator&lt;
    AcIn extends any[], AcOut,
    ActionType extends string = string,
> (
    actionCreatorOrThunk: Fun&lt;AcIn, AcOut>,
    dispatch: Fun&lt;[AcOut]>,
    type?: ActionType,
): WithTypeField&lt;Fun&lt;AcIn, ReturnTypeOrType&lt;AcOut>>, ActionType> {
    const boundActionCreatorOrThunk =
        (...args: AcIn) => dispatch(actionCreatorOrThunk(...args));
    if (
        isWithTypeField&lt;typeof actionCreatorOrThunk, ActionType>(
            actionCreatorOrThunk,
        )
    ) {
        boundActionCreatorOrThunk.type = actionCreatorOrThunk.type;
    } else {
        boundActionCreatorOrThunk.type = (
            type ?? `${actionCreatorOrThunk.name}()`
        ) as ActionType;
    }
    return boundActionCreatorOrThunk;
}




/**
 * Redux's original `bindActionCreators` clone with extended `Action`
 * support (original function assumes dispatch parametrized with redux's
 * `UnknownAction` which is not compatible with `Action`).
 *
 * Turns an object with action creators or thunks into an object with every
 * action creator wrapped into a `dispatch` call.
 *
 * @function bindActionCreators
 * @param actionCreators Object with action creator functions
 * @param dispatch redux store's `dispatch` function
 * @returns Object with wrapped action creators
 */
export function bindActionCreators&lt;
    ActionCreators extends { [P in keyof ActionCreators]: ActionCreators[P] },
    AcOuts = ActionCreators[keyof ActionCreators],
    BoundActionCreators = {
        [P in keyof ActionCreators]:
            WithTypeField&lt;
                Fun&lt;
                    Parameters&lt;ActionCreators[P]>,
                    ReturnTypeOrType&lt;ReturnType&lt;ActionCreators[P]>>
                >
            >
    },
> (
    actionCreators: ActionCreators,
    dispatch: Fun&lt;[AcOuts]>,
    treeName?: string,
): BoundActionCreators {
    return objectMap(actionCreators) (
        ([k, a]) => [
            k,
            bindActionCreator(
                a, dispatch,
                treeName ? `${treeName}.${String(k)}()` : `${String(k)}()`,
            ),
        ],
    ) as BoundActionCreators;
}




/**
 * Bind whole tree of action creators to the redux's dispatch function.
 *
 * @function bindActionCreatorsTree
 * @param acTree Object with `actionCreators` objects
 * @param dispatch redux store's `dispatch` function
 * @returns Object with wrapped action creators
 */
export function bindActionCreatorsTree&lt;
    ACTree extends { [P in keyof ACTree]: ACTree[P] },
    ActionCreators = ACTree[keyof ACTree],
    AcOuts = ActionCreators[keyof ActionCreators],
    BoundACTree = {
        [P in keyof ACTree]:
            ReturnType&lt;
                typeof bindActionCreators&lt;
                    ACTree[P], ACTree[P][keyof ACTree[P]]
                >
            >
    },
> (
    acTree: ACTree,
    dispatch: Fun&lt;[AcOuts]>,
): BoundACTree {
    return objectMap(acTree) (
        ([k, a]) => [k, bindActionCreators(a, dispatch, String(k))],
    ) as BoundACTree;
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Fri Mar 01 2024 16:19:30 GMT+0100 (Central European Standard Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
